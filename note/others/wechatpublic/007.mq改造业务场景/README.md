# 语音识别消息队列业务场景



最近一个比较好的业务场景，是实习来接触的一个较为复杂的业务场景，也是实习的最后一个任务。



这是一个语言识别的任务，因为识别任务是大量的，而且客户端需要保证每条任务必须有结果。识别是通过c++程序实现的，每条任务的识别时间不等（5分钟左右）。因此在实际操作的时候还需注意很多细节。



- **任务服务**

  客户端发送请求，将记录添加到sql表内，然后通过定时任务将识别任务发送到对应的消息队列内。

- **识别服务**

  从消息队列中取出这条任务消息，然后进行识别。识别服务有中文、少儿英语、成人英语，但使用同一套逻辑。

- **消息队列**

  使用kafka，将生产者和消费者进行解耦



业务场景不算复杂，但是要保证所有任务正常运行，因此需要对消息进行补偿处理。

针对这点，因此数据库表中对每条任务设定状态（准备、队列、执行、成功、失败、完成）



如果任务在kafka或者识别过程中出现问题，则通过任务状态可以拿到该任务，重新发送即可。



因为任务的量额较大，而识别的程序根据cpu的核来定的，因此存在扩容的情况。原有topic分出较多partition以供识别服务来消费。



在原有基础上，添加了任务的优先级和减少partition。

后续申请的为pulsar，而非kafka

### 减少partition

通过在识别端使用chan加协程，制造一个小型生产者消费者模型来解决多partition的异常topic情况。利用chan的特性，从而避免使用锁的情况。

### 优先级

优先级任务则需要申请不同的消息队列，申请为pulsar。识别端也通过不同的chan来接收消息，利用select的特性，完成任务。

```GO
for {
    select {
    case msg := <-highchan:
        consume(msg)
    default:
        select {
        case msg := <-highchan:
        	consume(msg)
        case msg := <-lowchan:
        	consume(msg)  
        }
    }
}
```

实际操作中，这种优先级处理方式也是比较常见的。对应分配不同的权重则产生一个很不错的场景出来了。



kafka因其高吞吐量的特点，被广泛应用于各种场景，但也因其扩展的诟病让人难受。而pulsar在这方面做得不错。



一直对这种消息中间件有着极强的兴趣，这次终于实际上手操作了mq的业务场景。虽然在识别端无法进行单元测试，中间还一度出现日志打印与想象的出入，最终还是解决了，不错的业务体验。





