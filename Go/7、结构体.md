# 结构体



## 面向对象

Golang语言没有class，而是使用struct结构体来实现OOP特性的。

- **面向对象简洁**

  去掉了传统OOP的继承、方法重载、构造函数和析构函数、隐藏的this指针等

- **仍有封装、继承、多态的特性**

  Golan没有extends关键字，继承通过匿名字段来实现

- **面向接口编程**



## 声明

```go
type struct_use struct{
  Name string
  Age string
  Other string
}

//声名  已经有了地址，并将结构体内容进行了初始化
var no1 struct_use
fmt.Printf("%p",&no1)
//赋值
no1.Name = "zs"
```

- <a style="color:red">**注意**</a>

  结构体是一个值类型，而非为引用数据类型

  首字母大小写同样区分是否为public类型

  结构体所有字段在内存中是连续的



## 字段

- **基本类型字段**

  为各自类型的默认值，int(0)、bool(flase)、string(“”)

- **引用类型字段**

  如slice、指针、map、channel等，为nil，需要分配空间才能使用

  

## 创建结构体变量

```go
//第一种		类型为：main.Struct_Type
var s1 Struct_Type
s1.Name = "zs"

//第二种		类型为：main.Struct_Type
s2 := Struct_Type{
  Name: "zs",
}

//第三种		类型为：*main.Struct_Type
s3 := new(Struct_Type)
(*s3).Name = "zs"
s3.Name = "zs"	//这样赋值也可以，go会转化为上一行形式 

//第四种		类型为：*main.Struct_Type
s4 := &Struct_Type{
  Name:  "zs",
}
```



## Tag

- **结构体可以为每个字段写一个Tag**

  这个Tag可以通过反射来获取。常见使用场景为序列化和反序列化

  ```go
  //这里结构体内部的字段如果其他包要使用的话，首字母必须大小
  type Struct_Use struct {
    Name string
    Age int
  }
  
  //序列化使其转为字符串，但常用格式为首字母小写，这时应用Tag
  type Struct_Use struct {
  	Name string `json:"name"`
  	Age int	`json:"age"`
  }
  
  func main() {
  	s1 := Struct_Use{
  		Name: "zs",
  		Age: 19,
  	}
  	marshal, err := json.Marshal(s1)
  	if err != nil {
  		fmt.Println(err)
  	}
  	fmt.Println(string(marshal))
  }
  ```

- **Tag是使用反射机制来完成的**

